#summary EB: 战队编写及AI研究
#labels Phase-Support,AI

<wiki:toc/>

= EB世界 =
`EB是个真实的世界。我们可以这样理解：`
 * EB是个棋盘类的博弈游戏。
		想像一下，你与对手有1分钟的思考用时，1分钟后你们一起移动棋子。
		只不过在EB中，棋子的移动，按照方式的不同，耗时也不同。
		基于这一点，规则稍微变化一下，你与对手每隔1分钟可以移动棋子，棋子移动结束后才可以继续移动。棋子按照移动方式，耗时1分钟-4分钟不等。

 * EB是个砖块环境的实时战略游戏。
		EB的节拍我们可以认为是游戏主控逻辑的一个循环。我们可以在每个节拍计算我们的NPC的位置信息并更新。(跟通常的游戏不同，在EB中，我们的NPC是全能的神，他们可以知道战场上任意一个NPC的情况：位置、状态等。:))

 * EB是个战场模拟程序。
 		我们有10个士兵，但是我们可以增加自己的通讯指挥系统。这个在ERLANG中很方便，生成进程，发消息即可。士兵们或者自己行动，或者接受指挥统一行动。
 * ……
 
 不论如何，我们可以按照我们喜欢的方式，理解EB，建模EB，享受战斗，享受生活。:)

= 目标 =
 我希望我的部队有自己的决策系统，可以针对较复杂的情况进行有限的自行判断，而不是受限于特定的几种行动模式。

= 寻路 =
 寻路，顾名思义，寻找路径。
 
 这是基本的算法，任何游戏都要用到。怎样走到敌人跟前？走哪条路最近？中间有障碍物怎么办？这些都要用到寻路算法。

== 视线追逐算法 ==
 在砖块环境中，从一点移动到另外一点，简单有效的直线算法，就是Bresenham算法了。
 [http://erlbattle.googlecode.com/files/ai.7z 这里]做了一个简单的实现。

== A*算法 ==
 A*算法是个适用范围很广泛的寻路算法。它可以很好的处理途中遇见的障碍物，从而得到一条最好的路线。注意，找到的路线只是所有最好路线中的一条，但是可以保证不会有更好的路线没找到。
 A*算法是把Dijkstra算法和BFS算法结合的产物。它在搜索过程中像BFS一样使用启发式函数引导搜索过程。在从起点走向终点的过程中，A*会检查f(n)值最小的节点，其中f(n)=g(n)+h(n)。这里，g(n)就是起点到任意节点n的代价，h(n)是任意节点n到终点的评估代价。
 g(n)很容易得到，所有的信息都保存着。重要的是h(n)。在砖块环境中，最常用的h(n)就是曼哈顿距离：
 h(n) = abs(n.x – goal.x) + abs(n.y – goal.y)
 很符合我们EB环境。哈哈~~

 按照书A的内容：实现了一个A*算法。在[http://erlbattle.googlecode.com/files/ai.7z这里]。
 伪码：
 
 起点加入open list
 while open list 不空
 {
   当前节点 = open list中成本最低的节点
   if 当前节点 = 终点 then
    完成
   else
    当前节点加入closed list
    for 每个相邻节点
     if 该节点不在open list
      and 不在closed list
      and 不是障碍物
        该节点加入open list，计算成本
 }

= 参考书籍 =
 * 书A：[http://groups.google.com/group/erlbattle/files 《游戏开发中的人工智能》]
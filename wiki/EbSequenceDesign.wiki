#summary 如何控制战场时间节拍和指令顺序
#labels Phase-QA,Phase-Support

----

== 第四版结构图 ==

http://erlbattle.googlecode.com/files/theWorld-04.png

和第三版相比，增加了一个用于记录战场日志的 battleRecorder进程。 主程序在运算过程中，不断将战场状态发给这个进程（避免直接写文件影响时钟）， 这个进程收到消息后，先将日志缓冲到ets表中（private) ， 在收到主程序退出消息时，开始将内存缓冲写文件。 这个算法最大限度的避免写文件缓慢操作对于系统时钟节拍稳定性的影响。 


----

== 第三版结构图 ==
http://erlbattle.googlecode.com/files/theWorld-03.png 

和第二版相比，取消了worldclock 进程。 完全由erlbattle 进程自己运算，睡眠，再运算。其节拍完全自己可以控制。 

----

== 第二版结构图 ==
http://erlbattle.googlecode.com/files/theWorld.png  

图中浅蓝色的进程是eb 核心系统； 两个椭圆的进程是玩家开发的指挥进程。 浅黄色折角的是4个ets 表，用于在进程间传递信息； 

== 和第一稿设计的差异 ==

大家注意增加了两个channel 进程。通过这两个channel 进程的隔离， 玩家程序没有战场主程序的句柄，无法发送恶意消息去干扰主系统，或者对方的运行。 每个玩家程序都只能和自己的通道进程发生关系。 如果要恶意干扰，只能干扰自己。 

主战场程序只会接收到标准的时钟节拍消息，并处理之。 不会被其他消息延误时钟节拍的处理。 能够很平稳的运行。 


== 进程说明 ==

1. 战场进程 erlbattle
 这个是系统的核心进程，负责在时间节拍到达时，首先运算世界中各个战士动作（移动，转身，攻击），并将死去的战士挪出战场； 然后对于处于wait 状态的战士到redQueue, blueQueue 取下一步指令; 取完消息后，向消息队列进程发送清除指令的消息； 本进程负责维护战场状态表（battle_field）；

2. 时钟进程 worldclock
 专门负责维护世界的节拍。每个节拍延迟时间考虑采用测速方案，确保在不同速度的机器上，给予玩家指挥进程相同的CPU 处理指令次数。 worldclock 负责定期向主程序发出时钟节拍信号。 同时维护一个时钟表（battle_timer）

3. 红/蓝方消息队列进程 redChannel, blueChannel 
 负责接收来自玩家指挥进程的消息；然后维护各自维护自己的消息队列； 每个战士只有一个指令被缓存；老的如果没有被执行，就会被新的消息冲掉。 如果接受到战场进程发来的清除指令消息，就将已经被处理的消息清除

4. 玩家指挥进程
 由玩家编写的人工智能程序。 能够根据战场情况灵活指挥自己的队伍，攻击敌人，并取得胜利



== 共享ETS 表说明 ==

1. 战场状态表 battle_field
 由erlbattle 进程负责维护；记录战场上战士的状态。是protect named 表。 能够被玩家指挥进程看到

2. 世界时钟表 battle_clock
 由worldclock 进程负责维护，记录战场上的时间节拍。是protect named 表。 能够被玩家指挥进程看到

3. 红/蓝方指令缓冲表 redQueue, blueQueue
 分别由redChannel, blueChannel进程维护。 能够被主战场进程查看。 以及各自被自己方的玩家指挥进程看到，但不能被对方玩家的指挥进程看到。 是proted none-named 表。

图中虚线代表各个进程对于表的读取能力。 橙色大箭头表明维护的关系。


== 消息说明 ==

1. 红/蓝方指挥命令消息
 由指挥进程向各自的消息通道进程发送。 消息进程接收后，进行缓存

2. 时钟节拍消息
 由时钟进程定期向战场程序发送，启动战场程序进行一个节拍的运算

3. 清除指令消息
 由战场程序在完成了一轮的消息处理后，向两个消息通道进程发送。 通知消息通道进程将已经使用过的指令缓存清除


== 算法说明 ==

当我们程序收到决策程序发来的指令后，其实我们并不真的去执行那个动作，而是将其放到队列中。 每个战士的队列长度只有 1， 也就是说如果一个指令发过来进入队列后，没有及时被战场程序取走，又发来一个指令的话，后面的指令冲掉前面的指令。 

然后正好clock 发出的时间节拍指令来的时候， 对于时间消息的处理程序才是真正执行指令的代码入口。这个程序做几个动作：

1。首先去找战场状态表，将其中所有动作生效时间是当前的战士该移动的移动，该攻击的攻击。 这些战士完成了他的动作后，状态处于wait 了。 这代表这个战士已经准备好做下一个动作了。 而比如在20秒的时候发动一个向后退的动作，他的生效时间是 24秒。 在 20秒，21，22，23 秒的时候他都不能接受其他指令， 必须等到后退动作到 24秒完成后才能开始下一个动作。 

2. 将战场状态表中所有处于wait 状态的战士全部去上述的指令队列中找，看看决策程序规划的该战士下一个动作是什么。 大家注意，在接口规范文档中，提出的命令指令格式是：

        {command , 指令, 发起的战士，发动时间} 

 第四个参数“发动时间” 如果这个发动时间小于等于当前时间，这个动作就会被执行，主程序更新战场状态表中的战士动作，和预计发动时间字段。 如果决策程序希望一个动作立刻执行可以把 发动时间设为 0 。 这个0 永远小于当前时间因此你的动作永远会被立刻执行。 

 为什么说只查那些wait 状态的战士呢？  因为当你的刀挥出去后，还是要等刀落下，才能做另一个动作。或者你开始往后跨一步退的时候，要等这个脚落地，站稳，完成退的动作才能做下一个动作。 

 系统就是这样来控制节拍的。 

== 动作生效时间 ==

    * 向前移动一格：2秒
    * 转方向：1 秒
    * 向后退一格： 4秒
    * 发动一次攻击：2秒 

    当前时间是26的话，如果发出指令的话，真正生效的节拍是 26 + t. 也就是说移动发生在28. 转向发生在27， 后退发生在30，攻击发生在 28

----

== 第一版结构图 ==
http://erlbattle.googlecode.com/files/theWorld-01.png 

这版是最老的一个原型系统，最大的问题是玩家的指挥程序发出消息和时钟发出的消息都是直接进erlbattle战场主程序。 会造成互相影响， 恶意的玩家程序可以阻塞主系统对于对方指令和时钟节拍的处理。 这个问题在第二版设计中通过引入了隔离的通讯进程，让玩家只能向自己的通讯进程发消息，而不能向主进程发消息来解决。 恶意程序只能影响自己，没法影响别人

#summary 在高并行场景下，移动一个战士还真不容易

* 移动一个战士面临的困难 *
----
这几天开始编写【疯狗战阵】，算是个真正的指挥程序。 相信其他参赛选手估计也开始做了一些了。拿移动算法作例来讲： 

{{{
想让一个角色从 （2，2）  走到 （3， 3）
}}}


* 我们发出：foward, turnNorth, forward, turnEast, forword   消息就可以吗？远远要比这个复杂。 *


 <b>分析： </b>  channel 的消息队列是每个战士一个命令缓冲， 在没被主战场消耗前，后来的会冲掉前面的。 上例中，如果不做任何控制，直接连着发消息，的结果一定是只有最后那个forword 生效。 结果你位于（3，2）


* 那么我们每发一个就休息100秒行吗？ 也不行*

 <b>分析：</b> 首先战场程序每拍休息多久你不知道，那个是测速测出来的。可能是120 ，也可能是90.  即使是写死100， 由于除了睡100毫秒外，战场程序还有其他运算任务， 那个到底多少时间不是很确定。结果就不确定了。 可能最后的执行序列是：  forward, turnNorth,turn East, forward, 你位于（4，2）而不是（3，3）。


* 那么我们能否扫描battle_field表。 看到自己走到了正确位置后， 再发出下一个指令？  可以，但是还有问题 * 

 <b>分析：</b> 战场主程序的运行逻辑是，将改节拍生效的动作执行完成， 然后到队列中取所有处于wait 状态战士的下一个指令。 然后睡一会。 如果按照上面这种做法，当你扫描发现自己的上一个动作完成后， 再发出下一个消息的时候，显然已经错过了这拍。你的指令会在下一拍被收到。 对于战斗来讲，你就走得比别人慢一拍， 差这一点，结果差很多。

 另外还有包括如果正好有人档在你的行进路线上， 或者原来没档，但是后来节拍中，档了。 或者原来挡了，后来走开了。 一系列问题。 造成《移动一个战士还真不容易》；和决策程序比起来，EB 的主程序反而是非常非常简单的小东西。

<br>

* 解决思路：（抛砖引玉） *
----
考虑模仿人的行为模式。 当我们计划从A 点走到 B 点。 其实我们有两部分的控制体系。

 # 大脑： 决定今天中午去楼下的川菜馆吃饭。 从A -> B
 # 然后由小脑负责指挥我的身体，1，2，1，1，2，1 的走过去。 包括路上闪避自行车（顿一下，车过去，再走）， 绕道。。。路上保持平衡等。
 # 同时大脑根据宏观情况，决定是否要改变主意。 比如到门口一看，里面人狂多，一堆人站着等位置；大脑只能决定换到隔壁湘菜馆了。 或者路上看到美女同事也去吃饭，就邀请一起去西餐馆进餐。

回到EB. 我会为每个战士创建一个大脑进程。一个小脑进程。大脑负责制定出大的计划。  (2,2) -> (3,3)

小脑负责执行这些命令。

然后说下小脑的算法：

 # 小脑分析 battle_filed ，看看forword 指令如果现在发出，是否能够执行。 如果不行看看是否可以先走到2，3。 如果都不行的话，就等在原地等机会。直到能走。
 # 发出指令到queue.
 # 监视这个指令是否在战场表中出现了。 也就是说指令已经从队列中取出来了。
 # 分析该指令是否一定会成功。 比如另外有个人（我方，或者敌方） 在T+2 的时间也会进入该位置的话，就有可能我的动作会失败。我会留在原地。 那样的话就要重新设法执行该动作。 如果肯定会成功， 我就发出下一个指令到队列中。 如果不一定，我就要等T+2 , 确认自己的位置后，才能发下一个指令
 # 然后再从新的位置评估去到最终目标的办法。
 # 还要随时等着接收大脑发出的新的计划。 一旦收到新计划，就要制定新的方案。

貌似很复杂啊。。。。。饿狼就是给大家创造了这么个环境来编程。 



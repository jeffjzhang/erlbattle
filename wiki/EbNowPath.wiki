#summary 项目的进化和开发过程

----
*2009年6月18日*

在ERLANG CHINA 上正式启动项目. 在ZOOM 的帮助下,在GOOGLE CODE 上安了家. ZOOM 给这个计划取了一个好听的 恶狼战役 的名称.  ERL --> 恶狼  真是非常贴切. 而用ERLANG 开发出来的程序的特点就是海量进程并行运算,这些进程就像一个狼群, 虽然没个都打不过老虎,但是一个组织有序的狼群足够消灭任何地面的生物. 

----
*2009年6月27日*

放了一个hello world 上去。 正式开始编码。 和其他开源项目不同， 这个项目是由完全的新手启动的项目，目的是学习ERLANG 编程。 因此第一个代码是从hello world 开始的。 

----
*2009年6月28日*

一边看书，一边把程序的架子搭起来。 在编写的过程中最大的体会是突然变量不能重复赋值了。 这对于一个做过PB, C,C++, JAVA 的老程序员而言，花了很长时间才习惯。 另外一个就是尾递归也是颠覆习惯思维的，在传统的编程中递归算法是最忌讳的。 而在ERLANG 中，没有递归什么都做不了。 

开发架子的时候还纠正了一个错误的认识，主程序启动了两个决策进程，我想当然认为当我把主进程停掉的时候，子进程也会自动关闭，结果发现子进程在那边无休无止的运行。只能把shell 强迫关掉。 进程在ERLANG 中是对等的。因此任何一个进程掉掉的话， 都可以由其他进程来负责恢复。 修改程序让主进程关闭前向子进程发出停止的指令，解决了这个问题。 

----
*2009年6月29日*

开始考虑如何处理指挥程序传来的消息。 原来的战场状态表只反映战士目前正在进行的动作，当消息不断传来的时候，需要先将该消息接收，并暂存起来。此时需要引入erlang 的ETS 表来做这个事情了。

ETS 表有named 和 非named 两种。 也有private, public, protected 三种模式。 

首先我们希望主程序负责维护这个队列，同时决策程序也要能够查看这个队列（知道自己的部队到底下一步会干嘛，因为决策程序不能确保主程序一定及时收到了自己的命令，或者当不断发命令后，可能自己都搞不清楚，自己部队的动作了）。但是每一方显然不应该看到对方的命令队列。

因此我们需要选择protected 模式， 以及 none-named 模式。 将对应的表的ID 传给能够看的进程。 

今天KarlMa 问了个问题，为什么时间要写到数据库表里面去？ 是怕运行时崩溃，重启动后再跑吗？
这个问题是对于ETS 表的误解。ETS 表是内存表， 当创建进程消亡后，自动消亡。之所以用ETS 放时间，主要是希望各个进程能够看到当前时间。已作出各种判断。 

使用named ets 是我现在想到的唯一一种进程间共享数据的方案，不知道这个对不对，请高手指点下！！！

----
*2009年7月3日*

对代码进行了第一次重构。 将测试，和一些独立功能分离出来。 每个erl 文件现在干的事情比较单一了。 这为未来进一步扩展创造更好的环境。 

创建了自动测试机制。 testAll：test(); 和编译 winmake 绑在一起。 

发现了erlang 书上的一个问题：

书上讲当创建ets表的进程终止后， 该表就会自动消亡。 测试下来发现不是这样。 当我们创建一个表，如果不关就结束的话。 下次运行时创建表的语句就会报错！！！ 报错后，再次执行就好了。所以我还是在所有进程结束前显式的写了 ets:delete 把屁股擦干净。 解决了这个问题。 

Karl 原来直觉是对的，被我误导了。 

*后续发展：*

这次我重构发现erlang 还是需要显式的调用ets:delete 掉时钟表，并做了修改。 开始没问题。 一切正常。 但是当我打开对于战场列表debug 功能后， 系统就崩溃了。

发现由于debug 战场列表， 对于战斗指令消息处理的速度大大降低。造成第一个时钟节拍后，开始处理指令消息的过程中，时钟过了5个节拍，然后认为战斗结束了，就把 时钟表删掉了。

这时还有大量堆积的命令消息没有处理，当系统处理这些命令消息时，去读时钟表。 系统就垮了。 我感觉书上说的可能也没错， 确实进程死掉后，其创建的ets 表会消亡。 但是可能是要过较长的时间才会。 因此原来不删时钟表的代码偶尔会崩溃。 而现在直接删时钟表的代码必然崩溃。

对于getTime 做了try 处理，提高容错性。 解决了这个问题。 

 